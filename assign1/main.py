import logging
import random
from collections import defaultdict
from heapq import heapify, heappop, heappush

import numpy as np

logging.basicConfig(format="%(levelname)s:%(message)s", level=logging.DEBUG)
logger = logging.getLogger(__name__)

NUM_PEERS = 5
EDGE_P = 0.5  # Edge probability
Z = 20  # Slow percent

NUM_TRANS = 5  # #transactions Generated by each peer
EXPO_MEAN = 1.0  # Param for expo dist for interarrival

q = list()


random.seed(42)
peers = list(range(NUM_PEERS))
chains = defaultdict(list)
seen_transactions = defaultdict(set)


def generate_random_transaction(source):
    """Returns source, dest, amt after generating a random transaction."""
    # source = random.randrange(NUM_PEERS)
    while (creditor := random.randrange(NUM_PEERS)) == source:
        pass
    amt = abs(100 * np.random.normal())
    return source, creditor, amt


def execute(time, func, *args):
    func(time, *args)


class Transaction:
    def __init__(self, tid, payer, payee, amt):
        self.id = tid
        self.payer = payer
        self.payee = payee
        self.amt = amt

    def __str__(self):
        return f"{self.id}: {self.payer} paid {self.payee} ${self.amt} coins."

    def __repr__(self):
        return f"{self.id}: {self.payer} =={self.amt}=> {self.payee}."


class Message:
    def __init__(self, txn, source, dest):
        self.trx = txn
        self.source, self.dest = source, dest

    def __str__(self):
        return f"{self.source} -> {self.dest}\n{self.trx}"

    def __gt__(self, m2):
        return self.source > m2.source


def generate_valid_graph(num=NUM_PEERS):
    """Keeps generating random graph until a valid graph is generated.
    Valid => One single component; all nodes reachable.
    """

    logger.info("Attempting to create a valid graph...")

    def generate_random_graph(num=num):
        """Generates a random graph."""
        logger.debug("Generating candidate graph")
        graph = defaultdict(list)
        for i in range(num):
            for j in range(i):
                is_edge = np.random.choice(2, p=[1 - EDGE_P, EDGE_P])
                if is_edge:
                    graph[i].append(j)
                    graph[j].append(i)
        return graph

    def check_validity(graph):
        if len(graph) < num:
            return False
        visited = {0}
        stack = [0]
        while stack:
            node = stack.pop()
            for neigh in graph[node]:
                if neigh not in visited:
                    stack.append(neigh)
                    visited.add(neigh)
        return len(visited) == num

    while not check_validity((graph := generate_random_graph())):
        logger.debug("Invalid Graph: %s", graph)
    logger.info("Generated graph")
    logger.debug("Valid Graph: %s", graph)
    return graph


graph = generate_valid_graph()


def _transact(time, trx: Transaction):
    """Execute a transaction on the source node.

    Create events of sending transaction info to itself for simplification."""
    logger.info(f"{time}s: Created transaction: {trx}")
    heappush(q, (time, _receive, Message(trx, trx.payer, trx.payer)))


def _receive(time, message: Message):
    """Execute a message receive, by scheduling for forwarding messages.
    TODO: Add to blockchain tree etc.
    """
    logger.info(f"{time}s: Message recvd: {message}")
    if message.trx.id in seen_transactions[message.dest]:
        return
    seen_transactions[message.dest].add(message.trx.id)
    # TODO: Other blockchain stufff
    for neigh in graph[message.dest]:
        if message.source != neigh:
            # TODO: schedule receiving messsage for later
            rec_time = time + 1  # TODO: Simulate latency
            heappush(q, (rec_time, _receive, Message(message.trx, message.dest, neigh)))


def populate_transaction_events():
    """Populates initial transaction queue with transaction events."""
    interarrivals = np.random.exponential(EXPO_MEAN, (NUM_PEERS, NUM_TRANS))
    tid = 0
    for peer, peer_times in enumerate(interarrivals):
        t = 0
        for time in peer_times:
            t += time
            tid += 1
            q.append(
                (
                    time,
                    _transact,
                    Transaction(tid, *generate_random_transaction(peer)),
                )
            )
    logger.info("Generating transactions spread across time for each node.")
    assert (
        len(q) == NUM_TRANS * NUM_PEERS
    ), "Initial #transactions should be NUM_PEERS X NUM_TRANS"
    heapify(q)


def main():
    populate_transaction_events()
    while q:
        execute(*heappop(q))


if __name__ == "__main__":
    main()
