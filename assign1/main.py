import logging
import random
from collections import defaultdict, Counter
from heapq import heapify, heappop, heappush

import numpy as np

logging.basicConfig(format="%(levelname)s:%(message)s", level=logging.DEBUG)
logger = logging.getLogger(__name__)
random.seed(42)
np.random.seed(42)

NUM_PEERS = 10
EDGE_P = 0.5  # Edge probability
Z = 20  # Slow percent
if Z >= 1:
    Z = Z / 100

NUM_TRANS = 5  # #transactions Generated by each peer
EXPO_MEAN = 1.0  # Param for expo dist for interarrival

q = list()

# Create link speed matrix c
is_fast = np.random.choice([True, False], NUM_PEERS, p=[1 - Z, Z])
c = np.empty((NUM_PEERS, NUM_PEERS))
for i in range(NUM_PEERS):
    for j in range(NUM_PEERS):
        c[i][j] = 5 + (is_fast[i] and is_fast[j]) * 95


AVG_MINING_TIME = np.empty(NUM_PEERS)
for i in range(NUM_PEERS):
    AVG_MINING_TIME = 500 + is_fast[i] * 500


# Create propagation delay matrix p; values in ms
p = np.random.uniform(10, 500, (NUM_PEERS, NUM_PEERS))
p = (p + p.T)/2

##
peers = list(range(NUM_PEERS))
chains = defaultdict(list)
seen_transactions = defaultdict(set)
pool = defaultdict(list)


def generate_random_transaction(source):
    """Returns source, dest, amt after generating a random transaction."""
    # source = random.randrange(NUM_PEERS)
    while (creditor := random.randrange(NUM_PEERS)) == source:
        pass
    amt = abs(100 * np.random.normal())
    return source, creditor, amt


def execute(time, func, *args):
    func(time, *args)


class Transaction:
    def __init__(self, tid, payer, payee, amt):
        self.id = tid
        self.payer = payer
        self.payee = payee
        self.amt = amt

    def __str__(self):
        return f"{self.id}: {self.payer} paid {self.payee} ${self.amt} coins."

    def __repr__(self):
        return f"{self.id}: {self.payer} =={self.amt}=> {self.payee}."


class Message:
    def __init__(self, txn, source, dest):
        self.trx = txn
        self.source, self.dest = source, dest

    def __str__(self):
        return f"{self.source} -> {self.dest}\n{self.trx}"

    def __gt__(self, m2):
        return self.source > m2.source


class Block:
    def __init__(self, generator, prev_block, trxs):
        self.prev = prev_block
        self.trxs = trxs
        self.generator = generator

    def block_balance(self):
        ledger = defaultdict(int)
        ledger[self.generator] = 50
        for trx in self.trxs:
            ledger[trx.payer] -= trx.amt
            ledger[trx.payee] += trx.amt
        return Counter(ledger)

    def overall_balance(self):
        ledger = Counter()
        node = self
        while node is not None:
            ledger.update(node.block_balance())
            node = node.prev
        return ledger

    def is_valid(self):
        """Determines if the current block has valid trxs only.

        The balance of any payer may not go below zero at any point.
        """
        ledger = self.prev.overall_balance()
        for trx in self.trxs:
            ledger[trx.payer] -= trx.amt
            if ledger[trx.payer] < 0:
                return False
        return True

    def height(self):
        if self.prev is None:
            return 0
        return self.prev.height() + 1


##
# ##### Block testing and debugging ####
#"""
genesis = Block(-1, None, list())
b1 = Block(1, genesis, [Transaction(0, 2, 3, 5), Transaction(1, 3, 2, 10)])
b2 = Block(1, genesis, [])
b3 = Block(2, b2, [Transaction(2, 1, 5, 20), Transaction(3, 1, 7, 15)])
b4 = Block(2, b3, [Transaction(5, 2, 5, 50), Transaction(4, 1, 7, 25)])
print(b4.is_valid())
#"""
##


def generate_valid_graph(num=NUM_PEERS):
    """Keeps generating random graph until a valid graph is generated.
    Valid => One single component; all nodes reachable.
    """

    logger.info("Attempting to create a valid graph...")

    def generate_random_graph(num=num):
        """Generates a random graph."""
        logger.debug("Generating candidate graph")
        graph = defaultdict(list)
        for i in range(num):
            for j in range(i):
                is_edge = np.random.choice(2, p=[1 - EDGE_P, EDGE_P])
                if is_edge:
                    graph[i].append(j)
                    graph[j].append(i)
        return graph

    def check_validity(graph):
        if len(graph) < num:
            return False
        visited = {0}
        stack = [0]
        while stack:
            node = stack.pop()
            for neigh in graph[node]:
                if neigh not in visited:
                    stack.append(neigh)
                    visited.add(neigh)
        return len(visited) == num

    while not check_validity((graph := generate_random_graph())):
        logger.debug("Invalid Graph: %s", graph)
    logger.info("Generated graph")
    logger.debug("Valid Graph: %s", graph)
    return graph


graph = generate_valid_graph()


def _transact(time, trx: Transaction):
    """Initiate a transaction on the source node.

    Create events of sending transaction info to itself for simplification."""
    logger.info(f"{time}s: Created transaction: {trx}")
    heappush(q, (time, _receive, Message(trx, trx.payer, trx.payer)))


def _receive(time, message: Message):
    """Execute a message receive, by scheduling for forwarding messages.
    TODO: Add to blockchain tree etc.
    """
    logger.info(f"{time}s: Message recvd: {message}")
    if message.trx.id in seen_transactions[message.dest]:
        return
    seen_transactions[message.dest].add(message.trx.id)
    pool[message.dest].append(message.trx)
    # TODO: Other blockchain stufff
    for neigh in graph[message.dest]:
        if message.source != neigh:
            cij = c[message.dest][neigh]  # kb/ms
            mc = 8 / cij   # ms
            d = np.random.exponential(96/cij)  # ms
            latency = (p[message.dest][neigh] + mc + d) / 1000  # s
            rec_time = time + latency
            heappush(q, (rec_time, _receive, Message(message.trx, message.dest, neigh)))


def populate_transaction_events():
    """Populates initial transaction queue with transaction events."""
    interarrivals = np.random.exponential(EXPO_MEAN, (NUM_PEERS, NUM_TRANS))
    tid = 0
    for peer, peer_times in enumerate(interarrivals):
        t = 0
        for time in peer_times:
            t += time
            tid += 1
            q.append(
                (
                    time,
                    _transact,
                    Transaction(tid, *generate_random_transaction(peer)),
                )
            )
    logger.info("Generating transactions spread across time for each node.")
    assert (
        len(q) == NUM_TRANS * NUM_PEERS
    ), "Initial #transactions should be NUM_PEERS X NUM_TRANS"
    heapify(q)


def populate_init_mining_events():
    for peer in range(NUM_PEERS):
        pass


def main():
    populate_transaction_events()
    populate_init_mining_events()
    while q:
        execute(*heappop(q))


if __name__ == "__main__":
    main()


# Genesis, 0001
# Genesis, 0002
# 0001, 0005
# 0001, 0006
# Genesis, 0003
# 0003, 0007
# 0002, 0008
# 0005, 0009




# genesis
# 0001                                00002                                0003
# 00005   0006                          0008                              0007
# 0009
